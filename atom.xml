<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汪茫人海</title>
  
  
  <link href="https://marklinglon.github.io/atom.xml" rel="self"/>
  
  <link href="https://marklinglon.github.io/"/>
  <updated>2024-02-01T09:54:30.238Z</updated>
  <id>https://marklinglon.github.io/</id>
  
  <author>
    <name>mark long</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>K个一组反转列表</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:54:30.238Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val  <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 检查链表长度是否满足反转条件</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> count &lt; k &#123;</span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转当前 K 个节点</span></span><br><span class="line">    prev := reverseList(head, current)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理下一组 K 个节点</span></span><br><span class="line">    head.Next = reverseKGroup(current, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head, tail *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> prev, next *ListNode</span><br><span class="line">    current := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> current != tail &#123;</span><br><span class="line">        next = current.Next</span><br><span class="line">        current.Next = prev</span><br><span class="line">        prev = current</span><br><span class="line">        current = next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printList</span><span class="params">(head *ListNode)</span></span> &#123;</span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, current.Val)</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个链表</span></span><br><span class="line">    head := &amp;ListNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">    head.Next = &amp;ListNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">    head.Next.Next = &amp;ListNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">    head.Next.Next.Next = &amp;ListNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">    head.Next.Next.Next.Next = &amp;ListNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定 K 的值</span></span><br><span class="line">    k := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表每 K 个节点</span></span><br><span class="line">    result := reverseKGroup(head, k)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;反转后的链表: &quot;</span>)</span><br><span class="line">    printList(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="K个一组反转列表" scheme="https://marklinglon.github.io/tags/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>求最小数</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/minInt/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/minInt/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:20:37.251Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span> <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(nums)</span> </span>== <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 列表为空时返回一个合适的默认值，或者根据实际情况决定如何处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最小值为列表的第一个元素</span></span><br><span class="line">    min := nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表，更新最小值</span></span><br><span class="line">    <span class="keyword">for</span> _, num := range nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &lt; min &#123;</span><br><span class="line">            min = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cla</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最小数" scheme="https://marklinglon.github.io/tags/%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存机制</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T10:00:50.331Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span></span><br><span class="line">cache    <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">head     *Node</span><br><span class="line">tail     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">prev  *Node</span><br><span class="line">next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">capacity: capacity,</span><br><span class="line">cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node),</span><br><span class="line">head:     <span class="literal">nil</span>,</span><br><span class="line">tail:     <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line"><span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> put(key, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新节点值</span></span><br><span class="line">node.value = value</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">node := &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">lru.cache[key] = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存已满，淘汰最久未使用的节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt; lru.capacity &#123;</span><br><span class="line">lru.removeTail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新节点添加到头部</span></span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node != lru.head &#123;</span><br><span class="line">lru.removeNode(node)</span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeNode(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">node.prev.next = node.next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.head = node.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.next != <span class="literal">nil</span> &#123;</span><br><span class="line">node.next.prev = node.prev</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.tail = node.prev</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> addToHead(node *Node) &#123;</span><br><span class="line">node.prev = <span class="literal">nil</span></span><br><span class="line">node.next = lru.head</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.head != <span class="literal">nil</span> &#123;</span><br><span class="line">lru.head.prev = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lru.head = node</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">lru.tail = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeTail() &#123;</span><br><span class="line"><span class="keyword">if</span> lru.tail != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(lru.cache, lru.tail.key)</span><br><span class="line">lru.removeNode(lru.tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建容量为 2 的 LRU 缓存</span></span><br><span class="line">lru := Constructor(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">lru.put(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">lru.put(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 2 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 2 的结果:&quot;</span>, lru.get(<span class="number">2</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 1 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 3 的结果:&quot;</span>, lru.get(<span class="number">3</span>)) <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 4 的结果:&quot;</span>, lru.get(<span class="number">4</span>)) <span class="comment">// 输出 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LRU缓存机制" scheme="https://marklinglon.github.io/tags/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/xzList/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/xzList/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:34:16.104Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type MyQueue struct &#123;</span><br><span class="line">    inStack  \<span class="selector-attr">[\]</span>int</span><br><span class="line">    outStack \<span class="selector-attr">[\]</span>int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">Constructor</span>() MyQueue &#123;</span><br><span class="line">    return MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Enqueue</span>(x int) &#123;</span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.inStack</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Dequeue</span>() int &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.transfer</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，返回一个合适的默认值，或者根据实际情况决定如何处理</span></span><br><span class="line">        return <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val := <span class="selector-tag">q</span>.outStack\<span class="selector-attr">[len(q.outStack)-1\]</span></span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="selector-tag">q</span>.outStack\<span class="selector-attr">[:len(q.outStack)-1\]</span></span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">transfer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.inStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.outStack</span>, <span class="selector-tag">q</span>.inStack\<span class="selector-attr">[len(q.inStack)-1\]</span>)</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="selector-tag">q</span>.inStack\<span class="selector-attr">[:len(q.inStack)-1\]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    queue := <span class="built_in">Constructor</span>()</span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">1</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">2</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：1</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：2</span></span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：3</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="旋转排序数组" scheme="https://marklinglon.github.io/tags/%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>用栈实现队列</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/zhanQueue/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/zhanQueue/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:29:22.790Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type MyQueue struct &#123;</span><br><span class="line">    inStack  <span class="selector-attr">[]</span>int</span><br><span class="line">    outStack <span class="selector-attr">[]</span>int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">Constructor</span>() MyQueue &#123;</span><br><span class="line">    return MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Enqueue</span>(x int) &#123;</span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.inStack</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Dequeue</span>() int &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.transfer</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，返回一个合适的默认值，或者根据实际情况决定如何处理</span></span><br><span class="line">        return <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val := <span class="selector-tag">q</span><span class="selector-class">.outStack</span><span class="selector-attr">[len(q.outStack)-1]</span></span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="selector-tag">q</span><span class="selector-class">.outStack</span><span class="selector-attr">[:len(q.outStack)-1]</span></span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">transfer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.inStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.outStack</span>, <span class="selector-tag">q</span><span class="selector-class">.inStack</span><span class="selector-attr">[len(q.inStack)-1]</span>)</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="selector-tag">q</span><span class="selector-class">.inStack</span><span class="selector-attr">[:len(q.inStack)-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    queue := <span class="built_in">Constructor</span>()</span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">1</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">2</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：1</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：2</span></span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：3</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="栈 队列" scheme="https://marklinglon.github.io/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>不含AAA或BBB的字符串</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%ABAAA%E6%88%96BBB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%ABAAA%E6%88%96BBB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:48:43.450Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateString</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">result := <span class="string">&quot;&quot;</span></span><br><span class="line">countA, countB := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> countA+countB &lt; <span class="number">7</span> &#123; <span class="comment">// 控制字符串长度，这里选择了 7，你可以根据实际情况调整</span></span><br><span class="line"><span class="keyword">if</span> countA &lt; <span class="number">2</span> || (countA &gt;= <span class="number">2</span> &amp;&amp; countB &lt; <span class="number">1</span>) &#123;</span><br><span class="line">result += <span class="string">&quot;A&quot;</span></span><br><span class="line">countA++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result += <span class="string">&quot;B&quot;</span></span><br><span class="line">countB++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := generateString()</span><br><span class="line">fmt.Println(<span class="string">&quot;生成的字符串:&quot;</span>, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="不含AAA或BBB的字符串" scheme="https://marklinglon.github.io/tags/%E4%B8%8D%E5%90%ABAAA%E6%88%96BBB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:36:49.346Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是 p 或 q，则它本身就是最近公共祖先</span></span><br><span class="line">    <span class="keyword">if</span> root == p || root == q &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在左子树中递归寻找最近公共祖先</span></span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在右子树中递归寻找最近公共祖先</span></span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左右子树分别找到 p 和 q，则当前节点是最近公共祖先</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树找到 p 或 q，则返回左子树的结果</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子树找到 p 或 q，则返回右子树的结果</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">    root.Left = &amp;TreeNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line">    root.Right = &amp;TreeNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">    root.Left.Left = &amp;TreeNode&#123;Val: <span class="number">6</span>&#125;</span><br><span class="line">    root.Left.Right = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">    root.Right.Left = &amp;TreeNode&#123;Val: <span class="number">0</span>&#125;</span><br><span class="line">    root.Right.Right = &amp;TreeNode&#123;Val: <span class="number">8</span>&#125;</span><br><span class="line">    root.Left.Right.Left = &amp;TreeNode&#123;Val: <span class="number">7</span>&#125;</span><br><span class="line">    root.Left.Right.Right = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个节点</span></span><br><span class="line">    p := root.Left</span><br><span class="line">    q := root.Left.Right.Right</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最近公共祖先</span></span><br><span class="line">    result := lowestCommonAncestor(root, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最近公共祖先的值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;节点 %d 和节点 %d 的最近公共祖先是节点 %d\n&quot;</span>, p.Val, q.Val, result.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树的最近公共祖先" scheme="https://marklinglon.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>合并区间</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:55:53.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>合并区间是一个常见的算法问题，目标是将重叠的区间合并成一个或多个不重叠的区间。以下是一个用 Golang 实现的例子：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interval <span class="keyword">struct</span> &#123;</span><br><span class="line">Start <span class="type">int</span></span><br><span class="line">End   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals []Interval)</span></span> []Interval &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(intervals) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将区间按照起始位置进行排序</span></span><br><span class="line">sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intervals[i].Start &lt; intervals[j].Start</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">merged := []Interval&#123;intervals[<span class="number">0</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">current := intervals[i]</span><br><span class="line">lastMerged := merged[<span class="built_in">len</span>(merged)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前区间与上一个合并后的区间是否有重叠</span></span><br><span class="line"><span class="keyword">if</span> current.Start &lt;= lastMerged.End &#123;</span><br><span class="line"><span class="comment">// 有重叠，更新合并后的区间的结束位置</span></span><br><span class="line">merged[<span class="built_in">len</span>(merged)<span class="number">-1</span>].End = max(lastMerged.End, current.End)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 无重叠，直接加入合并后的结果</span></span><br><span class="line">merged = <span class="built_in">append</span>(merged, current)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一组区间</span></span><br><span class="line">intervals := []Interval&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">8</span>, <span class="number">10</span>&#125;,</span><br><span class="line">&#123;<span class="number">15</span>, <span class="number">18</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并区间</span></span><br><span class="line">result := merge(intervals)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Println(<span class="string">&quot;合并后的区间:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;合并区间是一个常见的算法问题，目标是将重叠的区间合并成一个或多个不重叠的区间。以下是一个用 Golang 实现的例子：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="合并区间" scheme="https://marklinglon.github.io/tags/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>四数组相加II</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%9B%9B%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%9B%9B%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0II/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:39:12.750Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(A []<span class="type">int</span>, B []<span class="type">int</span>, C []<span class="type">int</span>, D []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sumCount := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计A和B数组中元素的和的组合</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> A &#123;</span><br><span class="line">        <span class="keyword">for</span> _, b := <span class="keyword">range</span> B &#123;</span><br><span class="line">            sumCount[a+b]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历C和D数组，查找和的相反数在sumCount中的数量</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> C &#123;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> D &#123;</span><br><span class="line">            result += sumCount[-(c + d)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    B := []<span class="type">int</span>&#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    C := []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    D := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    count := fourSumCount(A, B, C, D)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;满足条件的组合数量是：%d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="四数组相加II" scheme="https://marklinglon.github.io/tags/%E5%9B%9B%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0II/"/>
    
  </entry>
  
  <entry>
    <title>子集</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:57:59.724Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">backtrack(nums, []<span class="type">int</span>&#123;&#125;, &amp;result, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums, current []<span class="type">int</span>, result *[][]<span class="type">int</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(current))</span><br><span class="line"><span class="built_in">copy</span>(temp, current)</span><br><span class="line">*result = <span class="built_in">append</span>(*result, temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">current = <span class="built_in">append</span>(current, nums[i])</span><br><span class="line">backtrack(nums, current, result, i+<span class="number">1</span>)</span><br><span class="line">current = current[:<span class="built_in">len</span>(current)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 给定集合</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求子集</span></span><br><span class="line">result := subsets(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Println(<span class="string">&quot;所有可能的子集:&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="子集" scheme="https://marklinglon.github.io/tags/%E5%AD%90%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>字符串解码</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T10:03:18.548Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">stack := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">currentNum := <span class="number">0</span></span><br><span class="line">currentStr := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> char &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; char &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是数字，更新当前数字</span></span><br><span class="line">currentNum = currentNum*<span class="number">10</span> + <span class="type">int</span>(char-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是左括号，将当前数字和字符串入栈，并重置</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentStr, fmt.Sprint(currentNum))</span><br><span class="line">currentStr = <span class="string">&quot;&quot;</span></span><br><span class="line">currentNum = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;]&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是右括号，出栈数字和字符串，进行解码</span></span><br><span class="line">num, _ := fmt.Sprint(stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">prevStr := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">repeatedStr := strings.Repeat(currentStr, numToInt(num))</span><br><span class="line">currentStr = prevStr + repeatedStr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是字母，追加到当前字符串</span></span><br><span class="line">currentStr += <span class="type">string</span>(char)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numToInt</span><span class="params">(numStr <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">num, _ := fmt.Sprint(numStr)</span><br><span class="line">result := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, digit := <span class="keyword">range</span> num &#123;</span><br><span class="line">result = result*<span class="number">10</span> + <span class="type">int</span>(digit-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 示例字符串</span></span><br><span class="line">encodedStr := <span class="string">&quot;3[a2[bc]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码字符串</span></span><br><span class="line">decodedStr := decodeString(encodedStr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;解码后的字符串: %s\n&quot;</span>, decodedStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串解码" scheme="https://marklinglon.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的锯齿型层次遍历</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:45:29.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树的锯齿形层次遍历是指从左到右和从右到左交替进行的层次遍历。在锯齿形层次遍历中，奇数层从左到右遍历，偶数层从右到左遍历。以下是一个用 Golang 实现的例子：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        result += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    total := sum(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;数组 %v 的和是 %d\n&quot;</span>, numbers, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val   <span class="type">int</span></span><br><span class="line">Left  *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line">level := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">currentLevel := <span class="built_in">make</span>([]<span class="type">int</span>, levelSize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前层的奇偶性判断插入顺序</span></span><br><span class="line"><span class="keyword">if</span> level%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">currentLevel[i] = node.Val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">currentLevel[levelSize-i<span class="number">-1</span>] = node.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将左右子节点加入队列</span></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">append</span>(result, currentLevel)</span><br><span class="line">level++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个二叉树</span></span><br><span class="line">root := &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">root.Left = &amp;TreeNode&#123;Val: <span class="number">9</span>&#125;</span><br><span class="line">root.Right = &amp;TreeNode&#123;Val: <span class="number">20</span>&#125;</span><br><span class="line">root.Right.Left = &amp;TreeNode&#123;Val: <span class="number">15</span>&#125;</span><br><span class="line">root.Right.Right = &amp;TreeNode&#123;Val: <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行锯齿形层次遍历</span></span><br><span class="line">result := zigzagLevelOrder(root)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;二叉树的锯齿形层次遍历是指从左到右和从右到左交替进行的层次遍历。在锯齿形层次遍历中，奇数层从左到右遍历，偶数层从右到左遍历。以下是一个用 Golang 实现的例子：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树的锯齿型层次遍历" scheme="https://marklinglon.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>数组中的第K个最大元素</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T10:01:49.308Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span></span><br><span class="line">cache    <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">head     *Node</span><br><span class="line">tail     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">prev  *Node</span><br><span class="line">next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">capacity: capacity,</span><br><span class="line">cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node),</span><br><span class="line">head:     <span class="literal">nil</span>,</span><br><span class="line">tail:     <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line"><span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> put(key, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新节点值</span></span><br><span class="line">node.value = value</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">node := &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">lru.cache[key] = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存已满，淘汰最久未使用的节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt; lru.capacity &#123;</span><br><span class="line">lru.removeTail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新节点添加到头部</span></span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node != lru.head &#123;</span><br><span class="line">lru.removeNode(node)</span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeNode(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">node.prev.next = node.next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.head = node.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.next != <span class="literal">nil</span> &#123;</span><br><span class="line">node.next.prev = node.prev</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.tail = node.prev</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> addToHead(node *Node) &#123;</span><br><span class="line">node.prev = <span class="literal">nil</span></span><br><span class="line">node.next = lru.head</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.head != <span class="literal">nil</span> &#123;</span><br><span class="line">lru.head.prev = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lru.head = node</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">lru.tail = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeTail() &#123;</span><br><span class="line"><span class="keyword">if</span> lru.tail != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(lru.cache, lru.tail.key)</span><br><span class="line">lru.removeNode(lru.tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建容量为 2 的 LRU 缓存</span></span><br><span class="line">lru := Constructor(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">lru.put(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">lru.put(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 2 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 2 的结果:&quot;</span>, lru.get(<span class="number">2</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 1 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 3 的结果:&quot;</span>, lru.get(<span class="number">3</span>)) <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 4 的结果:&quot;</span>, lru.get(<span class="number">4</span>)) <span class="comment">// 输出 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组中的第K个最大元素" scheme="https://marklinglon.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>对称二叉树</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:47:58.131Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type TreeNode struct &#123;</span><br><span class="line">Val   int</span><br><span class="line"><span class="keyword">Left</span>  *TreeNode</span><br><span class="line"><span class="keyword">Right</span> *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isSymmetric(root *TreeNode) bool &#123;</span><br><span class="line"><span class="keyword">if</span> root == nil &#123;</span><br><span class="line"><span class="keyword">return</span> true</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isMirror(root.<span class="keyword">Left</span>, root.<span class="keyword">Right</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isMirror(<span class="built_in">left</span>, <span class="built_in">right</span> *TreeNode) bool &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">left</span> == nil &amp;&amp; <span class="built_in">right</span> == nil &#123;</span><br><span class="line"><span class="keyword">return</span> true</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">left</span> == nil |<span class="type">| right</span> == nil &#123;</span><br><span class="line"><span class="keyword">return</span> false</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">left</span>.Val == <span class="built_in">right</span>.Val &amp;&amp; isMirror(<span class="built_in">left</span>.<span class="keyword">Left</span>, <span class="built_in">right</span>.<span class="keyword">Right</span>) &amp;&amp; isMirror(<span class="built_in">left</span>.<span class="keyword">Right</span>, <span class="built_in">right</span>.<span class="keyword">Left</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个对称二叉树</span><br><span class="line">root := &amp;TreeNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">root.<span class="keyword">Left</span> = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">root.<span class="keyword">Right</span> = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">root.<span class="keyword">Left</span>.<span class="keyword">Left</span> = &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">root.<span class="keyword">Left</span>.<span class="keyword">Right</span> = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">root.<span class="keyword">Right</span>.<span class="keyword">Left</span> = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">root.<span class="keyword">Right</span>.<span class="keyword">Right</span> = &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">// 判断二叉树是否对称</span><br><span class="line">result := isSymmetric(root)</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight coq&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="对称二叉树" scheme="https://marklinglon.github.io/tags/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>数组求和</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:34:01.610Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        result += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    total := sum(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;数组 %v 的和是 %d\n&quot;</span>, numbers, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="求和" scheme="https://marklinglon.github.io/tags/%E6%B1%82%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>整数反转</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:50:24.852Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">        digit := x % <span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查溢出情况</span></span><br><span class="line">        <span class="keyword">if</span> result &gt; (<span class="number">1</span>&lt;&lt;<span class="number">31</span><span class="number">-1</span>)/<span class="number">10</span> || (result == (<span class="number">1</span>&lt;&lt;<span class="number">31</span><span class="number">-1</span>)/<span class="number">10</span> &amp;&amp; digit &gt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result &lt; (<span class="number">-1</span>&lt;&lt;<span class="number">31</span>)/<span class="number">10</span> || (result == (<span class="number">-1</span>&lt;&lt;<span class="number">31</span>)/<span class="number">10</span> &amp;&amp; digit &lt; <span class="number">-8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = result*<span class="number">10</span> + digit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">12345</span></span><br><span class="line">    reversed := reverse(num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;整数 %d 的反转结果是 %d\n&quot;</span>, num, reversed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="整数反转" scheme="https://marklinglon.github.io/tags/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>根到叶子结点的数字之和</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:59:20.427Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode, currentSum <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前路径上的数字之和</span></span><br><span class="line">    currentSum = currentSum*<span class="number">10</span> + node.Val</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是叶子结点，返回当前路径的数字之和</span></span><br><span class="line">    <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentSum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树的数字之和</span></span><br><span class="line">    <span class="keyword">return</span> dfs(node.Left, currentSum) + dfs(node.Right, currentSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">    root.Left = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">    root.Right = &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">    root.Left.Left = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">    root.Left.Right = &amp;TreeNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算根到叶子结点的数字之和</span></span><br><span class="line">    result := sumNumbers(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;根到叶子结点的数字之和是：%d\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="根到叶子结点的数字之和" scheme="https://marklinglon.github.io/tags/%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>组合数组</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E7%BB%84/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E7%BB%84%E5%90%88%E6%95%B0%E7%BB%84/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:35:43.785Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    array2 := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    combinedArray := <span class="built_in">append</span>(array1, array2...)</span><br><span class="line">    fmt.Println(combinedArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组 组合" scheme="https://marklinglon.github.io/tags/%E6%95%B0%E7%BB%84-%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>最大正方形</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:43:37.055Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare</span><span class="params">(matrix [][]<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rows, cols := <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, rows)</span><br><span class="line">    maxSide := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dp &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, cols)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> dp[i] &#123;</span><br><span class="line">            dp[i][j] = <span class="type">int</span>(matrix[i][j] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                maxSide = <span class="number">1</span> <span class="comment">// 初始化最大边长为1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; cols; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])) + <span class="number">1</span></span><br><span class="line">                maxSide = max(maxSide, dp[i][j])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    matrix := [][]<span class="type">byte</span>&#123;</span><br><span class="line">        &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    area := maximalSquare(matrix)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;最大正方形的面积是：%d\n&quot;</span>, area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最大正方形" scheme="https://marklinglon.github.io/tags/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>路径总和</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:52:07.775Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是叶子节点，判断路径上的和是否等于目标和</span></span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> targetSum == root.Val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归判断左右子树是否存在路径满足条件</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line">    root.Left = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">    root.Right = &amp;TreeNode&#123;Val: <span class="number">8</span>&#125;</span><br><span class="line">    root.Left.Left = &amp;TreeNode&#123;Val: <span class="number">11</span>&#125;</span><br><span class="line">    root.Left.Left.Left = &amp;TreeNode&#123;Val: <span class="number">7</span>&#125;</span><br><span class="line">    root.Left.Left.Right = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">    root.Right.Left = &amp;TreeNode&#123;Val: <span class="number">13</span>&#125;</span><br><span class="line">    root.Right.Right = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">    root.Right.Right.Right = &amp;TreeNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定目标和</span></span><br><span class="line">    targetSum := <span class="number">22</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在路径满足条件</span></span><br><span class="line">    result := hasPathSum(root, targetSum)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;是否存在路径和为 %d 的路径: %v\n&quot;</span>, targetSum, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="路径总和" scheme="https://marklinglon.github.io/tags/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    
  </entry>
  
</feed>
