<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汪茫人海</title>
  
  
  <link href="https://marklinglon.github.io/atom.xml" rel="self"/>
  
  <link href="https://marklinglon.github.io/"/>
  <updated>2024-04-19T05:17:58.477Z</updated>
  <id>https://marklinglon.github.io/</id>
  
  <author>
    <name>mark long</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>interviewing</title>
    <link href="https://marklinglon.github.io/2024/04/19/%E9%9D%A2%E8%AF%95/interviewing/"/>
    <id>https://marklinglon.github.io/2024/04/19/%E9%9D%A2%E8%AF%95/interviewing/</id>
    <published>2024-04-18T16:00:00.000Z</published>
    <updated>2024-04-19T05:17:58.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis的数据类型"><a class="markdownIt-Anchor" href="#redis的数据类型"></a> redis的数据类型</h1><p>字符串：value是一个字符串<br />列表：value是一个列表<br />hash：value是一个key-value集合<br />set：value是一个没有重复数据的字符串集合<br />zset（sorted set）：value包含score和member，member不可以重复，score可以</p><h1 id="redis中穿透-击穿-雪崩的区别"><a class="markdownIt-Anchor" href="#redis中穿透-击穿-雪崩的区别"></a> redis中穿透、击穿、雪崩的区别</h1><p>穿透：缓存中不存在<br />击穿：某个缓存过期<br />雪崩：大量缓存过期<br />解决：布隆过滤器、简单的缓存校验、缓存永不过期、异步更新缓存时间、使用不同的缓存过期时间等</p><h1 id="mq的模式"><a class="markdownIt-Anchor" href="#mq的模式"></a> mq的模式</h1><p>简单模式（点对点）：P-&gt;queue-&gt;C，单一的消费者<br />work queues：P-&gt;queue-&gt;(c1,c2,c3…),不止一个消费者<br />public/subscribe发布订阅：P-X-queue1，queue2-&gt;(c1,c2,c3…),<br />在workqueue的基础上多了一个转换器，而且队列也变成了多种<br />X：exchange交换机，一方面接收消息，一方面知道如何处理这些消息<br />exchange也有多种：<br />广播：将消息交给所有绑定到交换机的队列<br />定向（路由模式）：把消息交给制定routing key的队列<br />topic（通配符）：把消息交给符合routing pattern路由模式的队列<br />routing路由模式：与发布订阅模式相似，不同的是队列与交换机的绑定不能是任意的了，而是要制定一个<br />routing key，只有队列的routing key和消息的routing key一致，队列才能接收到消息<br />topics主题模式：与路由模式类似，区别在于，绑定的key支持统配<br />rpc模式：rabbitmq的工作模式，属于点对点的同步模式</p><h1 id="k8s-service的类型"><a class="markdownIt-Anchor" href="#k8s-service的类型"></a> k8s service的类型</h1><p>包括 ClusterIP、NodePort、LoadBalancer 等。其中，LoadBalancer 类型的 Service 可以使用云服务提供商的负载均衡器（如AWS ELB、GCP Load Balancer）来实现负载均衡。</p><h1 id="k8s-的屋头服务"><a class="markdownIt-Anchor" href="#k8s-的屋头服务"></a> k8s 的屋头服务</h1><p>它与普通服务（具有 ClusterIP）不同。无头服务在定义时通过将 .spec.clusterIP 设置为空来声明，这使得它没有集群内部的虚拟 IP 地址。无头服务的作用是为了让客户端直接访问服务的后端 Pod 的网络地址，而不是通过 Service 的虚拟 IP 地址。</p><h1 id="k8s的健康检查的探针类型"><a class="markdownIt-Anchor" href="#k8s的健康检查的探针类型"></a> k8s的健康检查的探针类型</h1><p>存活探针（Liveness Probe）：<br />存活探针用于检测容器是否处于运行状态。如果存活探针失败（返回失败状态），Kubernetes 将杀死容器并重新启动它。这有助于处理容器内部发生的假死或死锁等情况。<br />就绪探针（Readiness Probe）：<br />就绪探针用于检测容器是否已准备好接受流量。如果就绪探针失败（返回失败状态），Kubernetes 将从服务负载均衡中删除该容器，直到就绪探针再次成功为止。这有助于避免将流量发送到尚未完全启动或初始化的容器。<br />启动探针（Startup Probe）：<br />启动探针是 Kubernetes 1.16 版本中引入的一种探针类型。它类似于存活探针，但它只在容器启动时执行一次，而不是在整个容器生命周期内定期执行。启动探针用于检测容器是否已经准备好接受流量，并且它的超时时间比存活探针的超时时间更长。</p><h1 id="kubernetes-中有几种健康检查方式用于确保容器的健康状态"><a class="markdownIt-Anchor" href="#kubernetes-中有几种健康检查方式用于确保容器的健康状态"></a> Kubernetes 中有几种健康检查方式，用于确保容器的健康状态：</h1><p>HTTP 健康检查：<br />使用 HTTP 健康检查时，Kubernetes 会周期性地向容器发送 HTTP 请求，并检查响应的状态码。如果响应状态码指示成功，则容器被视为健康；否则，容器被标记为不健康，可能会被重新启动。<br />TCP 健康检查：<br />TCP 健康检查通过向容器发送 TCP 连接请求，并检查连接是否成功建立来确定容器的健康状态。如果连接成功建立，则容器被视为健康；否则，容器被标记为不健康，可能会被重新启动。<br />命令执行健康检查：<br />命令执行健康检查会周期性地执行指定的命令或脚本，并检查其返回状态码来确定容器的健康状态。如果命令或脚本返回成功状态码，则容器被视为健康；否则，容器被标记为不健康，可能会被重新启动。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis的数据类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#redis的数据类型&quot;&gt;&lt;/a&gt; redis的数据类型&lt;/h1&gt;
&lt;p&gt;字符串：value是一个字符串&lt;br /&gt;
列表：value是一个列表&lt;br /&gt;
hash：v</summary>
      
    
    
    
    <category term="面试" scheme="https://marklinglon.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="interviewing 面试" scheme="https://marklinglon.github.io/tags/interviewing-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>K个一组反转列表</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:54:30.238Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val  <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 检查链表长度是否满足反转条件</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> count &lt; k &#123;</span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转当前 K 个节点</span></span><br><span class="line">    prev := reverseList(head, current)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理下一组 K 个节点</span></span><br><span class="line">    head.Next = reverseKGroup(current, k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head, tail *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> prev, next *ListNode</span><br><span class="line">    current := head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> current != tail &#123;</span><br><span class="line">        next = current.Next</span><br><span class="line">        current.Next = prev</span><br><span class="line">        prev = current</span><br><span class="line">        current = next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printList</span><span class="params">(head *ListNode)</span></span> &#123;</span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, current.Val)</span><br><span class="line">        current = current.Next</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个链表</span></span><br><span class="line">    head := &amp;ListNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">    head.Next = &amp;ListNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">    head.Next.Next = &amp;ListNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">    head.Next.Next.Next = &amp;ListNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">    head.Next.Next.Next.Next = &amp;ListNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定 K 的值</span></span><br><span class="line">    k := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表每 K 个节点</span></span><br><span class="line">    result := reverseKGroup(head, k)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Print(<span class="string">&quot;反转后的链表: &quot;</span>)</span><br><span class="line">    printList(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="K个一组反转列表" scheme="https://marklinglon.github.io/tags/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>LRU缓存机制</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T10:00:50.331Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span></span><br><span class="line">cache    <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">head     *Node</span><br><span class="line">tail     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">prev  *Node</span><br><span class="line">next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">capacity: capacity,</span><br><span class="line">cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node),</span><br><span class="line">head:     <span class="literal">nil</span>,</span><br><span class="line">tail:     <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line"><span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> put(key, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新节点值</span></span><br><span class="line">node.value = value</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">node := &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">lru.cache[key] = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存已满，淘汰最久未使用的节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt; lru.capacity &#123;</span><br><span class="line">lru.removeTail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新节点添加到头部</span></span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node != lru.head &#123;</span><br><span class="line">lru.removeNode(node)</span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeNode(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">node.prev.next = node.next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.head = node.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.next != <span class="literal">nil</span> &#123;</span><br><span class="line">node.next.prev = node.prev</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.tail = node.prev</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> addToHead(node *Node) &#123;</span><br><span class="line">node.prev = <span class="literal">nil</span></span><br><span class="line">node.next = lru.head</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.head != <span class="literal">nil</span> &#123;</span><br><span class="line">lru.head.prev = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lru.head = node</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">lru.tail = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeTail() &#123;</span><br><span class="line"><span class="keyword">if</span> lru.tail != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(lru.cache, lru.tail.key)</span><br><span class="line">lru.removeNode(lru.tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建容量为 2 的 LRU 缓存</span></span><br><span class="line">lru := Constructor(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">lru.put(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">lru.put(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 2 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 2 的结果:&quot;</span>, lru.get(<span class="number">2</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 1 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 3 的结果:&quot;</span>, lru.get(<span class="number">3</span>)) <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 4 的结果:&quot;</span>, lru.get(<span class="number">4</span>)) <span class="comment">// 输出 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LRU缓存机制" scheme="https://marklinglon.github.io/tags/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/xzList/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/xzList/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:34:16.104Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type MyQueue struct &#123;</span><br><span class="line">    inStack  \<span class="selector-attr">[\]</span>int</span><br><span class="line">    outStack \<span class="selector-attr">[\]</span>int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">Constructor</span>() MyQueue &#123;</span><br><span class="line">    return MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Enqueue</span>(x int) &#123;</span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.inStack</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Dequeue</span>() int &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.transfer</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，返回一个合适的默认值，或者根据实际情况决定如何处理</span></span><br><span class="line">        return <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val := <span class="selector-tag">q</span>.outStack\<span class="selector-attr">[len(q.outStack)-1\]</span></span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="selector-tag">q</span>.outStack\<span class="selector-attr">[:len(q.outStack)-1\]</span></span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">transfer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.inStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.outStack</span>, <span class="selector-tag">q</span>.inStack\<span class="selector-attr">[len(q.inStack)-1\]</span>)</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="selector-tag">q</span>.inStack\<span class="selector-attr">[:len(q.inStack)-1\]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    queue := <span class="built_in">Constructor</span>()</span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">1</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">2</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：1</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：2</span></span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：3</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="旋转排序数组" scheme="https://marklinglon.github.io/tags/%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>求最小数</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/minInt/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/minInt/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:20:37.251Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">findMin</span><span class="params">(nums []<span class="type">int</span>)</span> <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">len</span><span class="params">(nums)</span> </span>== <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 列表为空时返回一个合适的默认值，或者根据实际情况决定如何处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最小值为列表的第一个元素</span></span><br><span class="line">    min := nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历列表，更新最小值</span></span><br><span class="line">    <span class="keyword">for</span> _, num := range nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &lt; min &#123;</span><br><span class="line">            min = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cla</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="最小数" scheme="https://marklinglon.github.io/tags/%E6%9C%80%E5%B0%8F%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>不含AAA或BBB的字符串</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%ABAAA%E6%88%96BBB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%B8%8D%E5%90%ABAAA%E6%88%96BBB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:48:43.450Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateString</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">result := <span class="string">&quot;&quot;</span></span><br><span class="line">countA, countB := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> countA+countB &lt; <span class="number">7</span> &#123; <span class="comment">// 控制字符串长度，这里选择了 7，你可以根据实际情况调整</span></span><br><span class="line"><span class="keyword">if</span> countA &lt; <span class="number">2</span> || (countA &gt;= <span class="number">2</span> &amp;&amp; countB &lt; <span class="number">1</span>) &#123;</span><br><span class="line">result += <span class="string">&quot;A&quot;</span></span><br><span class="line">countA++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result += <span class="string">&quot;B&quot;</span></span><br><span class="line">countB++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := generateString()</span><br><span class="line">fmt.Println(<span class="string">&quot;生成的字符串:&quot;</span>, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="不含AAA或BBB的字符串" scheme="https://marklinglon.github.io/tags/%E4%B8%8D%E5%90%ABAAA%E6%88%96BBB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>用栈实现队列</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/zhanQueue/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/zhanQueue/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:29:22.790Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type MyQueue struct &#123;</span><br><span class="line">    inStack  <span class="selector-attr">[]</span>int</span><br><span class="line">    outStack <span class="selector-attr">[]</span>int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="built_in">Constructor</span>() MyQueue &#123;</span><br><span class="line">    return MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Enqueue</span>(x int) &#123;</span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.inStack</span>, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">Dequeue</span>() int &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.transfer</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空，返回一个合适的默认值，或者根据实际情况决定如何处理</span></span><br><span class="line">        return <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val := <span class="selector-tag">q</span><span class="selector-class">.outStack</span><span class="selector-attr">[len(q.outStack)-1]</span></span><br><span class="line">    <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="selector-tag">q</span><span class="selector-class">.outStack</span><span class="selector-attr">[:len(q.outStack)-1]</span></span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (<span class="selector-tag">q</span> *MyQueue) <span class="built_in">transfer</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(<span class="selector-tag">q</span>.inStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.outStack</span> = <span class="built_in">append</span>(<span class="selector-tag">q</span><span class="selector-class">.outStack</span>, <span class="selector-tag">q</span><span class="selector-class">.inStack</span><span class="selector-attr">[len(q.inStack)-1]</span>)</span><br><span class="line">        <span class="selector-tag">q</span><span class="selector-class">.inStack</span> = <span class="selector-tag">q</span><span class="selector-class">.inStack</span><span class="selector-attr">[:len(q.inStack)-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    queue := <span class="built_in">Constructor</span>()</span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">1</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">2</span>)</span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：1</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：2</span></span><br><span class="line"></span><br><span class="line">    queue<span class="selector-class">.Enqueue</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：3</span></span><br><span class="line">    fmt<span class="selector-class">.Println</span>(queue<span class="selector-class">.Dequeue</span>()) <span class="comment">// 输出：4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="栈 队列" scheme="https://marklinglon.github.io/tags/%E6%A0%88-%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:36:49.346Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是 p 或 q，则它本身就是最近公共祖先</span></span><br><span class="line">    <span class="keyword">if</span> root == p || root == q &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在左子树中递归寻找最近公共祖先</span></span><br><span class="line">    left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在右子树中递归寻找最近公共祖先</span></span><br><span class="line">    right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左右子树分别找到 p 和 q，则当前节点是最近公共祖先</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子树找到 p 或 q，则返回左子树的结果</span></span><br><span class="line">    <span class="keyword">if</span> left != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子树找到 p 或 q，则返回右子树的结果</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">    root.Left = &amp;TreeNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line">    root.Right = &amp;TreeNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">    root.Left.Left = &amp;TreeNode&#123;Val: <span class="number">6</span>&#125;</span><br><span class="line">    root.Left.Right = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">    root.Right.Left = &amp;TreeNode&#123;Val: <span class="number">0</span>&#125;</span><br><span class="line">    root.Right.Right = &amp;TreeNode&#123;Val: <span class="number">8</span>&#125;</span><br><span class="line">    root.Left.Right.Left = &amp;TreeNode&#123;Val: <span class="number">7</span>&#125;</span><br><span class="line">    root.Left.Right.Right = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个节点</span></span><br><span class="line">    p := root.Left</span><br><span class="line">    q := root.Left.Right.Right</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最近公共祖先</span></span><br><span class="line">    result := lowestCommonAncestor(root, p, q)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最近公共祖先的值</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;节点 %d 和节点 %d 的最近公共祖先是节点 %d\n&quot;</span>, p.Val, q.Val, result.Val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树的最近公共祖先" scheme="https://marklinglon.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的锯齿型层次遍历</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:45:29.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树的锯齿形层次遍历是指从左到右和从右到左交替进行的层次遍历。在锯齿形层次遍历中，奇数层从左到右遍历，偶数层从右到左遍历。以下是一个用 Golang 实现的例子：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        result += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    total := sum(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;数组 %v 的和是 %d\n&quot;</span>, numbers, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val   <span class="type">int</span></span><br><span class="line">Left  *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">queue := []*TreeNode&#123;root&#125;</span><br><span class="line">level := <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">levelSize := <span class="built_in">len</span>(queue)</span><br><span class="line">currentLevel := <span class="built_in">make</span>([]<span class="type">int</span>, levelSize)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; levelSize; i++ &#123;</span><br><span class="line">node := queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据当前层的奇偶性判断插入顺序</span></span><br><span class="line"><span class="keyword">if</span> level%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">currentLevel[i] = node.Val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">currentLevel[levelSize-i<span class="number">-1</span>] = node.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将左右子节点加入队列</span></span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">queue = <span class="built_in">append</span>(queue, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = <span class="built_in">append</span>(result, currentLevel)</span><br><span class="line">level++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个二叉树</span></span><br><span class="line">root := &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">root.Left = &amp;TreeNode&#123;Val: <span class="number">9</span>&#125;</span><br><span class="line">root.Right = &amp;TreeNode&#123;Val: <span class="number">20</span>&#125;</span><br><span class="line">root.Right.Left = &amp;TreeNode&#123;Val: <span class="number">15</span>&#125;</span><br><span class="line">root.Right.Right = &amp;TreeNode&#123;Val: <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行锯齿形层次遍历</span></span><br><span class="line">result := zigzagLevelOrder(root)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;二叉树的锯齿形层次遍历是指从左到右和从右到左交替进行的层次遍历。在锯齿形层次遍历中，奇数层从左到右遍历，偶数层从右到左遍历。以下是一个用 Golang 实现的例子：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="二叉树的锯齿型层次遍历" scheme="https://marklinglon.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%9E%8B%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>合并区间</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:55:53.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>合并区间是一个常见的算法问题，目标是将重叠的区间合并成一个或多个不重叠的区间。以下是一个用 Golang 实现的例子：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interval <span class="keyword">struct</span> &#123;</span><br><span class="line">Start <span class="type">int</span></span><br><span class="line">End   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(intervals []Interval)</span></span> []Interval &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(intervals) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intervals</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将区间按照起始位置进行排序</span></span><br><span class="line">sort.Slice(intervals, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> intervals[i].Start &lt; intervals[j].Start</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">merged := []Interval&#123;intervals[<span class="number">0</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(intervals); i++ &#123;</span><br><span class="line">current := intervals[i]</span><br><span class="line">lastMerged := merged[<span class="built_in">len</span>(merged)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前区间与上一个合并后的区间是否有重叠</span></span><br><span class="line"><span class="keyword">if</span> current.Start &lt;= lastMerged.End &#123;</span><br><span class="line"><span class="comment">// 有重叠，更新合并后的区间的结束位置</span></span><br><span class="line">merged[<span class="built_in">len</span>(merged)<span class="number">-1</span>].End = max(lastMerged.End, current.End)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 无重叠，直接加入合并后的结果</span></span><br><span class="line">merged = <span class="built_in">append</span>(merged, current)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一组区间</span></span><br><span class="line">intervals := []Interval&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#123;<span class="number">8</span>, <span class="number">10</span>&#125;,</span><br><span class="line">&#123;<span class="number">15</span>, <span class="number">18</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并区间</span></span><br><span class="line">result := merge(intervals)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Println(<span class="string">&quot;合并后的区间:&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;合并区间是一个常见的算法问题，目标是将重叠的区间合并成一个或多个不重叠的区间。以下是一个用 Golang 实现的例子：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="合并区间" scheme="https://marklinglon.github.io/tags/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>四数组相加II</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%9B%9B%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0II/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%9B%9B%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0II/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:39:12.750Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(A []<span class="type">int</span>, B []<span class="type">int</span>, C []<span class="type">int</span>, D []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sumCount := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计A和B数组中元素的和的组合</span></span><br><span class="line">    <span class="keyword">for</span> _, a := <span class="keyword">range</span> A &#123;</span><br><span class="line">        <span class="keyword">for</span> _, b := <span class="keyword">range</span> B &#123;</span><br><span class="line">            sumCount[a+b]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历C和D数组，查找和的相反数在sumCount中的数量</span></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> C &#123;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> D &#123;</span><br><span class="line">            result += sumCount[-(c + d)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    B := []<span class="type">int</span>&#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    C := []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    D := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">    count := fourSumCount(A, B, C, D)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;满足条件的组合数量是：%d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="四数组相加II" scheme="https://marklinglon.github.io/tags/%E5%9B%9B%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0II/"/>
    
  </entry>
  
  <entry>
    <title>子集</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%90%E9%9B%86/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:57:59.724Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">result := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">backtrack(nums, []<span class="type">int</span>&#123;&#125;, &amp;result, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(nums, current []<span class="type">int</span>, result *[][]<span class="type">int</span>, start <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(current))</span><br><span class="line"><span class="built_in">copy</span>(temp, current)</span><br><span class="line">*result = <span class="built_in">append</span>(*result, temp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">current = <span class="built_in">append</span>(current, nums[i])</span><br><span class="line">backtrack(nums, current, result, i+<span class="number">1</span>)</span><br><span class="line">current = current[:<span class="built_in">len</span>(current)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 给定集合</span></span><br><span class="line">nums := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求子集</span></span><br><span class="line">result := subsets(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Println(<span class="string">&quot;所有可能的子集:&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="子集" scheme="https://marklinglon.github.io/tags/%E5%AD%90%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>字符串解码</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T10:03:18.548Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">stack := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">currentNum := <span class="number">0</span></span><br><span class="line">currentStr := <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, char := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> char &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; char &lt;= <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是数字，更新当前数字</span></span><br><span class="line">currentNum = currentNum*<span class="number">10</span> + <span class="type">int</span>(char-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;[&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是左括号，将当前数字和字符串入栈，并重置</span></span><br><span class="line">stack = <span class="built_in">append</span>(stack, currentStr, fmt.Sprint(currentNum))</span><br><span class="line">currentStr = <span class="string">&quot;&quot;</span></span><br><span class="line">currentNum = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> char == <span class="string">&#x27;]&#x27;</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是右括号，出栈数字和字符串，进行解码</span></span><br><span class="line">num, _ := fmt.Sprint(stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">prevStr := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">repeatedStr := strings.Repeat(currentStr, numToInt(num))</span><br><span class="line">currentStr = prevStr + repeatedStr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 当前字符是字母，追加到当前字符串</span></span><br><span class="line">currentStr += <span class="type">string</span>(char)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> currentStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numToInt</span><span class="params">(numStr <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">num, _ := fmt.Sprint(numStr)</span><br><span class="line">result := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, digit := <span class="keyword">range</span> num &#123;</span><br><span class="line">result = result*<span class="number">10</span> + <span class="type">int</span>(digit-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 示例字符串</span></span><br><span class="line">encodedStr := <span class="string">&quot;3[a2[bc]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码字符串</span></span><br><span class="line">decodedStr := decodeString(encodedStr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;解码后的字符串: %s\n&quot;</span>, decodedStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="字符串解码" scheme="https://marklinglon.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>对称二叉树</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:47:58.131Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">type TreeNode struct &#123;</span><br><span class="line">Val   int</span><br><span class="line"><span class="keyword">Left</span>  *TreeNode</span><br><span class="line"><span class="keyword">Right</span> *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isSymmetric(root *TreeNode) bool &#123;</span><br><span class="line"><span class="keyword">if</span> root == nil &#123;</span><br><span class="line"><span class="keyword">return</span> true</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isMirror(root.<span class="keyword">Left</span>, root.<span class="keyword">Right</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func isMirror(<span class="built_in">left</span>, <span class="built_in">right</span> *TreeNode) bool &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">left</span> == nil &amp;&amp; <span class="built_in">right</span> == nil &#123;</span><br><span class="line"><span class="keyword">return</span> true</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">left</span> == nil |<span class="type">| right</span> == nil &#123;</span><br><span class="line"><span class="keyword">return</span> false</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">left</span>.Val == <span class="built_in">right</span>.Val &amp;&amp; isMirror(<span class="built_in">left</span>.<span class="keyword">Left</span>, <span class="built_in">right</span>.<span class="keyword">Right</span>) &amp;&amp; isMirror(<span class="built_in">left</span>.<span class="keyword">Right</span>, <span class="built_in">right</span>.<span class="keyword">Left</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个对称二叉树</span><br><span class="line">root := &amp;TreeNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">root.<span class="keyword">Left</span> = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">root.<span class="keyword">Right</span> = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">root.<span class="keyword">Left</span>.<span class="keyword">Left</span> = &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">root.<span class="keyword">Left</span>.<span class="keyword">Right</span> = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">root.<span class="keyword">Right</span>.<span class="keyword">Left</span> = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">root.<span class="keyword">Right</span>.<span class="keyword">Right</span> = &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">// 判断二叉树是否对称</span><br><span class="line">result := isSymmetric(root)</span><br><span class="line"></span><br><span class="line">// 输出结果</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight coq&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="对称二叉树" scheme="https://marklinglon.github.io/tags/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-03-11T02:51:14.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>] &#123;</span><br><span class="line">                arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;原始数组:&quot;</span>, arr)</span><br><span class="line">    bubbleSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">package <span class="selector-tag">main</span></span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="built_in">quickSort</span>(arr <span class="selector-attr">[]</span>int) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pivot := arr<span class="selector-attr">[0]</span></span><br><span class="line">    <span class="selector-tag">var</span> <span class="attribute">left</span>, right []int</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := range arr<span class="selector-attr">[1:]</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt;= pivot &#123;</span><br><span class="line">            <span class="attribute">left</span> = <span class="built_in">append</span>(left, v)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="attribute">right</span> = <span class="built_in">append</span>(right, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quickSort</span>(<span class="attribute">left</span>)</span><br><span class="line">    <span class="built_in">quickSort</span>(<span class="attribute">right</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">copy</span>(arr, <span class="attribute">left</span>)</span><br><span class="line">    arr<span class="selector-attr">[len(left)]</span> = pivot</span><br><span class="line">    <span class="built_in">copy</span>(arr<span class="selector-attr">[len(left)+1:]</span>, <span class="attribute">right</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="selector-tag">main</span>() &#123;</span><br><span class="line">    arr := <span class="selector-attr">[]</span>int&#123;<span class="number">64</span>, <span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">90</span>&#125;</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;原始数组:&quot;</span>, arr)</span><br><span class="line">    <span class="built_in">quickSort</span>(arr)</span><br><span class="line">    fmt<span class="selector-class">.Println</span>(<span class="string">&quot;排序后数组:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        minIdx := i</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[minIdx] &#123;</span><br><span class="line">                minIdx = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i], arr[minIdx] = arr[minIdx], arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;未排序前:&quot;</span>, arr)</span><br><span class="line">    selectionSort(arr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;排序后:&quot;</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#冒泡排序&quot;&gt;&lt;/a&gt; 冒泡排序&lt;/h2&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序算法" scheme="https://marklinglon.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组中的第K个最大元素</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T10:01:49.308Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">capacity <span class="type">int</span></span><br><span class="line">cache    <span class="keyword">map</span>[<span class="type">int</span>]*Node</span><br><span class="line">head     *Node</span><br><span class="line">tail     *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">key   <span class="type">int</span></span><br><span class="line">value <span class="type">int</span></span><br><span class="line">prev  *Node</span><br><span class="line">next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line"><span class="keyword">return</span> LRUCache&#123;</span><br><span class="line">capacity: capacity,</span><br><span class="line">cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Node),</span><br><span class="line">head:     <span class="literal">nil</span>,</span><br><span class="line">tail:     <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line"><span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> put(key, value <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> node, ok := lru.cache[key]; ok &#123;</span><br><span class="line"><span class="comment">// 更新节点值</span></span><br><span class="line">node.value = value</span><br><span class="line"><span class="comment">// 移动被访问的节点到头部</span></span><br><span class="line">lru.moveToHead(node)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line">node := &amp;Node&#123;key: key, value: value&#125;</span><br><span class="line">lru.cache[key] = node</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存已满，淘汰最久未使用的节点</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(lru.cache) &gt; lru.capacity &#123;</span><br><span class="line">lru.removeTail()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新节点添加到头部</span></span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> moveToHead(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node != lru.head &#123;</span><br><span class="line">lru.removeNode(node)</span><br><span class="line">lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeNode(node *Node) &#123;</span><br><span class="line"><span class="keyword">if</span> node.prev != <span class="literal">nil</span> &#123;</span><br><span class="line">node.prev.next = node.next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.head = node.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> node.next != <span class="literal">nil</span> &#123;</span><br><span class="line">node.next.prev = node.prev</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">lru.tail = node.prev</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> addToHead(node *Node) &#123;</span><br><span class="line">node.prev = <span class="literal">nil</span></span><br><span class="line">node.next = lru.head</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.head != <span class="literal">nil</span> &#123;</span><br><span class="line">lru.head.prev = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lru.head = node</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> lru.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">lru.tail = node</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span></span> removeTail() &#123;</span><br><span class="line"><span class="keyword">if</span> lru.tail != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(lru.cache, lru.tail.key)</span><br><span class="line">lru.removeNode(lru.tail)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建容量为 2 的 LRU 缓存</span></span><br><span class="line">lru := Constructor(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入键值对</span></span><br><span class="line">lru.put(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">lru.put(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 2 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 2 的结果:&quot;</span>, lru.get(<span class="number">2</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的键值对</span></span><br><span class="line">lru.put(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键 1 已经超出缓存容量，因此被淘汰</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 1 的结果:&quot;</span>, lru.get(<span class="number">1</span>)) <span class="comment">// 输出 -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 3 的结果:&quot;</span>, lru.get(<span class="number">3</span>)) <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询键 4</span></span><br><span class="line">fmt.Println(<span class="string">&quot;查询键 4 的结果:&quot;</span>, lru.get(<span class="number">4</span>)) <span class="comment">// 输出 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数组中的第K个最大元素" scheme="https://marklinglon.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>数组求和</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E6%B1%82%E5%92%8C/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:34:01.610Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        result += num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    total := sum(numbers)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;数组 %v 的和是 %d\n&quot;</span>, numbers, total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="求和" scheme="https://marklinglon.github.io/tags/%E6%B1%82%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>不含AAA或BBB的字符串</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-03-07T07:16:06.711Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := os.Args[<span class="number">1</span>]</span><br><span class="line">n_int, _ := strconv.Atoi(n)</span><br><span class="line">fmt.Println(Fibo(n_int))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibo</span><span class="params">(n <span class="type">int</span>)</span></span> (r <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Fibo(n<span class="number">-2</span>) + Fibo(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="不含AAA或BBB的字符串" scheme="https://marklinglon.github.io/tags/%E4%B8%8D%E5%90%ABAAA%E6%88%96BBB%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>整数反转</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:50:24.852Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">        digit := x % <span class="number">10</span></span><br><span class="line">        x /= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查溢出情况</span></span><br><span class="line">        <span class="keyword">if</span> result &gt; (<span class="number">1</span>&lt;&lt;<span class="number">31</span><span class="number">-1</span>)/<span class="number">10</span> || (result == (<span class="number">1</span>&lt;&lt;<span class="number">31</span><span class="number">-1</span>)/<span class="number">10</span> &amp;&amp; digit &gt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> result &lt; (<span class="number">-1</span>&lt;&lt;<span class="number">31</span>)/<span class="number">10</span> || (result == (<span class="number">-1</span>&lt;&lt;<span class="number">31</span>)/<span class="number">10</span> &amp;&amp; digit &lt; <span class="number">-8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = result*<span class="number">10</span> + digit</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">12345</span></span><br><span class="line">    reversed := reverse(num)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;整数 %d 的反转结果是 %d\n&quot;</span>, num, reversed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="整数反转" scheme="https://marklinglon.github.io/tags/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>根到叶子结点的数字之和</title>
    <link href="https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>https://marklinglon.github.io/2024/02/01/%E7%AE%97%E6%B3%95/%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</id>
    <published>2024-01-31T16:00:00.000Z</published>
    <updated>2024-02-01T09:59:20.427Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNumbers</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *TreeNode, currentSum <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前路径上的数字之和</span></span><br><span class="line">    currentSum = currentSum*<span class="number">10</span> + node.Val</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是叶子结点，返回当前路径的数字之和</span></span><br><span class="line">    <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentSum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算左右子树的数字之和</span></span><br><span class="line">    <span class="keyword">return</span> dfs(node.Left, currentSum) + dfs(node.Right, currentSum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    root := &amp;TreeNode&#123;Val: <span class="number">1</span>&#125;</span><br><span class="line">    root.Left = &amp;TreeNode&#123;Val: <span class="number">2</span>&#125;</span><br><span class="line">    root.Right = &amp;TreeNode&#123;Val: <span class="number">3</span>&#125;</span><br><span class="line">    root.Left.Left = &amp;TreeNode&#123;Val: <span class="number">4</span>&#125;</span><br><span class="line">    root.Left.Right = &amp;TreeNode&#123;Val: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算根到叶子结点的数字之和</span></span><br><span class="line">    result := sumNumbers(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;根到叶子结点的数字之和是：%d\n&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    <category term="算法" scheme="https://marklinglon.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="根到叶子结点的数字之和" scheme="https://marklinglon.github.io/tags/%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    
  </entry>
  
</feed>
